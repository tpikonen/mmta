#!/bin/sh
# mmta, a minimal mail transport agent
# Copyright: 2008-2013 Teemu Ikonen <tpikonen@gmail.com>
# License: GPLv3+

MMDA=@@MMDABIN@@
USERCONFEND=@@USERCONFDIR@@
USERCONFDIR="$HOME/$USERCONFEND"
SYSCONFDIR=@@SYSCONFDIR@@
PINGHOST="www.google.com"
PWFILE="/etc/passwd"
ALIASFILE="/etc/aliases"


# complain $MESSAGE
# Print and log a string
complain ()
{
    logger -t mmta "$1"
    echo "$1" >&2
}


# die $EXITCODE $MESSAGE
# Print and log a message and exit
die () {
    complain "$2"
    complain "Exiting with code $1"
    exit $1
}


is_online ()
{
    ping -c 1 -w 2 $PINGHOST > /dev/null 2>&1
}

# Routines for handling comma-separated lists

# append $LIST $A
# append $A to $LIST
append ()
{
    if [ -z "$1" ] ; then
        echo "$2"
    elif [ -z "$2" ] ; then
        echo "$1"
    else
        echo "$1,$2"
    fi
}


# cdr $LIST
# Get the tail part of $LIST, or empty string if list has one element
cdr ()
{
    echo "$1" | sed 's/^[^,]*,*\(.*\)/\1/'
}


# contains $LIST $A
# returns 0 if $LIST contains $A
contains()
{
    local PLIST ITEM P
    PLIST="$1"
    ITEM="$2"
    P=""
    while [ "$PLIST" != "$P" ] ; do
        P=${PLIST%%,*}
        PLIST=${PLIST#*,}
        if [ "$ITEM" = "$P" ] ; then
            return 0
        fi
    done
    return 1
}


# map_list $FUNC $LIST
# Apply $FUNC to each element of $LIST and output the result to stdout
# If $LIST is '-', read list from stdin
map_list ()
{
    local FUNC LIST A ALIST
    FUNC=$1
    LIST=$2

    if [ "$LIST" = "-" ] ; then
        ALIST=$(cat)
    else
        ALIST="$LIST"
    fi
    if [ -z "$ALIST" ] ; then
        return
    fi
    A=${ALIST%%,*}
    ALIST=$(cdr "$ALIST")
    $FUNC "$A"    
    while [ -n "$ALIST" ] ; do
        A=${ALIST%%,*}
        ALIST=$(cdr "$ALIST")
        echo -n ","
        $FUNC "$A"
    done
}


# Other functions

# Check if a given username is in /etc/passwd
# and the users shell is in /etc/shells
check_username()
{
    local USERSHELL
    USERSHELL=`grep "^${1}:" ${PWFILE} | cut -d: -f7`
    [ -n "$USERSHELL" ] || return 1
    grep -v '^#' /etc/shells | grep -q $USERSHELL
    return $?
}


# get_aliases $UNAME
# echo the logical line after $UNAME: in $ALIASFILE
get_aliases()
{
    local UNAME
    UNAME=$1
    [ -r $ALIASFILE ] && grep -v '^#' $ALIASFILE | sed -n "
/^$UNAME:/ {
    s/\\\\$// ; h ; t sawslash
    :loop
    $ b exit
    n
    s/^\S// ; t exit
    s/\\\\$// ; H ; $ b exit
    t sawslash
    b loop
    :sawslash
    n
    s/\\\\$// ; H ; $ b exit
    t sawslash
    b loop
    :exit
    x
    s/\n//g
    s/$UNAME:\s*//
    s/\s*,\s*/,/g
    s/,$//
    p
}"
    return 1
}


# resolve_aliases $USER
# Recursively alias-expand $USER. Output in global vars AL_LOCLIST, etc.
# If user does not have aliases, returns $USER
resolve_aliases()
{
    local USER PROCESSED A ALIST
    USER=$1
    PROCESSED=$1
    AL_LOCLIST=""
    AL_INETLIST=""
    AL_PIPELIST=""
    AL_FILELIST=""
    AL_INCLIST=""

    ALIST=$(get_aliases $USER)
    A=""
    while [ -n "$ALIST" ] ; do
        A=${ALIST%%,*}
        ALIST=$(cdr "$ALIST")
        if contains "$PROCESSED" "$A" ; then
            complain "Warning: aliases file has a loop with user $A"
            continue
        fi
        case "$A" in
            /*) # Filename
                AL_FILELIST=$(append "$AL_FILELIST" "$A") ;;
            \|*) # Pipe
                AL_PIPELIST=$(append "$AL_PIPELIST" "$A") ;;
            :*) # Include file
                AL_INCLIST=$(append "$AL_INCLIST" "$A") ;;
            *@*) # Inet mailaddress
                AL_INETLIST=$(append "$AL_INETLIST" "$A") ;;
            *) # Local address?
                LIST=$(get_aliases $A)
                if [ -n "$LIST" ] ; then
                    ALIST=$(append "$ALIST" "$LIST")
                    PROCESSED=$(append "$PROCESSED" "$A")
                else
                    AL_LOCLIST=$(append "$AL_LOCLIST" "$A")
                fi ;;
        esac
    done
    if [ -z "$AL_LOCLIST" ] ; then
        AL_LOCLIST=$USER
    fi
    return 1
}


# find_script $SCRIPTFILE $SHELLVAR
# Checks configuration directories for a given SCRIPTFILE and if
# found, sets the shell variable whose name is given in SHELLVAR
# to the full path of the script
find_script ()
{
    if [ -x "$USERCONFDIR/$1" ] ; then
        eval "$2=$USERCONFDIR/$1"
    elif [ -x "$SYSCONFDIR/$1" ] ; then
        eval "$2=$SYSCONFDIR/$1"
    else
        die 1 "Could not find script $1"
    fi
}


# read_header $FIELD
# return the content of a header field $FIELD from an
# RFC 2822 format file read from stdin
read_header ()
{
    local FIELD
    FIELD=$1

    sed -n "
    /^$/ q
    /^${FIELD}:/ {
        h
        :getline
        $ b output
        n
        /^$/ b output
        /^\S/ b output
        H ; b getline
        :output
        x
        s/^${FIELD}: *//
        s/\n//g
        p ; q
    }"
}


# clean_addr $ADDR
# Given an address read from RFC 2822 address header list (To: etc.)
# output only the email address and not the display-name part
clean_addr ()
{
    echo -n $1 | sed 's/.*<\(.*\)>.*/\1/'
}


# clear_bcc $FILE
# Remove the contents of the Bcc-header in RFC 2822 format $FILE
clear_bcc ()
{
    sed -i '/^$/ { :skip ; n ; b skip }
            /^Bcc:/ { s/^Bcc:.*$/Bcc:/ ; :end ; n ; b end }' $1
}


[ -x $MMDA ] || die 1 "Mail delivery program $MMDA not executable."

# Mail errors to sender by default
MAIL_ERRORS=1
SEND_TO_SELF=1
PARSE_MSG=0
RECIPIENTS=""
while [ $# -gt 0 ] ; do
    PAR=$1
    case $PAR in
        # sendmail options defined in LSB:
        -bm) # Read msg from stdin, default
            ;;
        -bp) # list mail-queue info,
            die 5 "Got option '-bp', mail queue listing is not supported."
            ;;
        -bs) # Read and write raw SMTP protocol, unsupported
            die 5 "Got option '-bs', direct SMTP protocol is not supported."
            ;;
        -F*) # Set the full name of the sender, unsupported
            complain "Option '-F' (set full name) not supported, continuing."
            ;;
        -f*) # Set the envelope from address (and From:, if there's none).
             # Unsopported.
            complain "Option '-f' (set envelope from) not supported, continuing"
            ;;
        -i|-oi) # Don't terminate reading input after a line with a single dot
            # not implemented yet (on by default)
            ;;
        -odb) # Deliver mail in background, ignored
            ;;
        -odf) # Deliver mail in foreground, default for local delivery,
              # otherwise ignored
            ;;
        -oem|-em) # Mail errors back to sender, default
            MAIL_ERRORS=1 ;;
        -oep|-ep) # Write errors to stderr
            MAIL_ERRORS=0 ;;
        -om) # Mail a copy to sender if sender appears in alias expansion
            SEND_TO_SELF=1 ;;
        -t) # Parse To:, Cc: and Bcc: header from msg to obtain recipients
            PARSE_MSG=1 ;;
        --) # Next arg is first recipient, break out
            shift
            break 2 ;;
        -*)
            complain "Warning: Ignoring unknown parameter $PAR" ;;
        *) # Already at first recipient
            break 2 ;;
    esac
    shift
done

for PAR in $@ ; do
    RECIPIENTS="$RECIPIENTS,$PAR"
done

TEMPF=$(tempfile)
[ "$?" = "0" ] || die 1 "Could not create a temporary file"

cat >> $TEMPF

if [ "$PARSE_MSG" = "1" ] ; then
    TOLIST=$(cat $TEMPF | read_header "To" | map_list "clean_addr" -)
    CCLIST=$(cat $TEMPF | read_header "Cc" | map_list "clean_addr" -)
    BCCLIST=$(cat $TEMPF | read_header "Bcc" | map_list "clean_addr" -)
    RECIPIENTS=$(append "$RECIPIENTS" "$TOLIST")
    RECIPIENTS=$(append "$RECIPIENTS" "$CCLIST")
    RECIPIENTS=$(append "$RECIPIENTS" "$BCCLIST")
    clear_bcc $TEMPF
fi

find_script "can-send" "CAN_SEND"
find_script "queue-mail" "QUEUE_MAIL"
find_script "send-queue" "SEND_QUEUE"

$CAN_SEND
SEND_INET=$?
if [ $SEND_INET = "0" ] ; then
    MARG="deliver"
else
    MARG="forward"
fi

# Local delivery loop
LOCAL_SENT=""
INET_RECV=""
FORWARDERS=""
ALIST=$RECIPIENTS
while [ -n "$ALIST" ]; do
    A=${ALIST%%,*}
    ALIST=$(cdr "$ALIST")
    R=${A%%@localhost*}
    R=${R%%@$HOSTNAME}
    case $R in
        *@*)
            INET_RECV=$(append "$INET_RECV" "$R")
            continue ;;
        *)
            resolve_aliases $R
            if [ "$R" != "$AL_LOCLIST" ] ; then
                ALIST=$(append "$AL_LOCLIST" "$ALIST")
                continue
            fi ;;
    esac
    if check_username "$R" ; then
        true
    else
        continue
    fi
    if contains "$LOCAL_SENT" "$R" ; then
        continue
    fi
    FLIST=$(cat $TEMPF | $MMDA $MARG $R)
    ECODE=$?
    if [ $ECODE != "0" ] ; then
        complain "Local delivery from $(whoami) to $R failed"
        complain "'$MMDA $MARG $R' exit code $ECODE"
    fi
    FLIST=$(echo $FLIST | sed -n '1h;1!H;${;g;s/\n/,/g;p;}')
    ALIST=$(append "$FLIST" "$ALIST")
    LOCAL_SENT=$(append "$LOCAL_SENT" "$R")
    if [ "$SEND_INET" != "0" ] ; then
        FORWARDERS=$(append "$FORWARDERS" "$R")
    fi
done

INET_RECV=$(echo -n ${INET_RECV} | tr ',' '\n' | sort | uniq | tr '\n' ',')

# Do internet delivery
if [ "$SEND_INET" = "0" ] ; then
    if [ -n "$INET_RECV" ] ; then
        QARGS=$(echo $INET_RECV | tr ',' ' ')
        cat $TEMPF | $QUEUE_MAIL $QARGS
        if is_online ; then
            $SEND_QUEUE
        fi
    fi
else
    if [ -n "$INET_RECV" ] ; then
        complain "Warning: Could not send to following external addresses: $INET_RECV"
    fi
    if is_online ; then
        # Run outgoing queues from people who were sent mail
        ALIST=$FORWARDERS
        ( while [ -n "$ALIST" ] ; do
            A=${ALIST%%,*}
            ALIST=$(cdr "$ALIST")
            $MMDA send $A
        done ) &
    fi
fi

rm -f $TEMPF
exit 0
